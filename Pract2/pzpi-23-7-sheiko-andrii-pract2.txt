Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук
Катедра програмної інженерії



ЗВІТ
до практичного завдання №2 з дисципліни
«Аналіз та рефакторинґ коду»
на тему: «Методи рефакторингу програмного коду»





Виконав: 						  	Перевірив:
ст. гр. ПЗПІ-23-7 					   	ст. викладач катедри ПІ
Шейко Андрій Олександрович 		   	Сокорчук Ігор Петрович









Харків 2025
1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	25.11.2025	1	Створено звіт



























2 ЗАВДАННЯ

Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code, дослідити основні рекомендації для написання якісного коду за допомогою цих методів, продемонструвати ці рекомендації на прикладах коду, обґрунтувати кожну рекомендацію і надати детальні пояснення та продемонструвати застосування обраних методів наочно.
	Кожен метод рефакторингу повинен супроводжуватись:
1)	Описом проблеми, яку вирішує даний метод;
2)	Кодом до і після застосування методу рефакторингу; 
3)	Поясненням переваг використаного методу
Для кожного стандарту оформлення студенту необхідно розробити наочні приклади коду, які демонструватимуть як некоректне, так і коректне застосування правил з детальними поясненнями щодо важливості дотримання кожного стандарту.
Студент повинен підготувати один або кілька прикладів коду, які демонструють, як потрібно застосовувати наведені рекомендації. Приклад коду може бути загальним і об'єднувати декілька рекомендацій, або ж студент може підготувати кілька окремих прикладів для різних аспектів рекомендацій.
	Студент повинен надати докладні пояснення щодо кожної рекомендації, підготувати слайди або текстову доповідь для презентації власного аналізу та представити свою доповідь викладачу.
	На основі проведеного дослідження студент має розробити презентацію українською мовою з мінімум 10 слайдів. Вступна частина повинна містити огляд обраної мови програмування, її історію розвитку та область застосування. Основна частина передбачає детальний розгляд конкретних стандартів оформлення з прикладами коду. Висновкова частина повинна включати аналіз важливості дотримання стандартів та їхнього впливу на якість коду. Презентація повинна бути структурованою, наочною та логічно послідовною.
	Студент повинен завантажити презентацію на навчальну платформу dl.nure.ua та розмістити приклади коду у репозиторії на GitHub з детальною документацією.




























3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ 
Рефакторинг — це системний процес покращення внутрішньої структури програмного коду без зміни його зовнішньої поведінки.  Метою є покращення читабельності, зрозумілості та підтримуваності коду, що полегшує його подальше розширення та тестування. Варто також підкреслити різницю між рефакторингом і переписуванням коду, оскільки ці два поняття зазвичай плутають. На відміну від переписування коду, рефакторинг не виправляє помилки та не додає нову функціональність, але робить код більш придатним для майбутніх змін.

	3.2 Мета рефакторингу 
	Насамперед, мета рефакторингу- це покращити ясність коду. Рефакторинг спрямований на перетворення програмного коду у більш прозорий, організований та легкий для сприйняття формат. Це дозволяє будь-якому розробнику, включаючи автора через місяці чи роки, швидко зрозуміти логіку та архітектуру програми.

По-друге, спростити внутрішню побудову системи. В процесі рефакторингу монолітні та заплутані блоки розділяються на компактні, фокусовані елементи — функції, модулі або класи. Такий підхід усуває надмірне копіювання коду, сприяє багаторазовому використанню компонентів і значно полегшує його подальше обслуговування.

По-третє, забезпечити гнучкість для модифікацій в майбутньому. Добре відрефакторений код стає фундаментом, на який можна безпечно надбудовувати новий функціонал або вносити виправлення. Чітка структура зменшує ризик побічних ефектів та робить процес тестування та розширення значно ефективнішим.

По-четверте, підвищити ефективність роботи команди. Коли кодова база має зрозумілу структуру, розробники менше часу витрачають на аналіз та відлагодження, а більше — на створення нових можливостей та вдосконалення продукту.

Отже, рефакторинг є стратегічною інвестицією у життєвий цикл проєкту, що забезпечує довгострокову стабільність, гнучкість та продуктивність процесу розробки.

3.3 Метод 1 «Декомпозиція умов»
3.3.1 Опис методу
	Це метод рефакторингу коду, який полягає в спрощенні складних умовних конструкцій шляхом винесення умов у окремі функції та виділення логіки гілок. Цей метод дозволяє підвищити читабельність коду, усуває дублювання, покращує підтримуваність та забезпечує гнучкість. Метод особливо ефективний для довгих або вкладених умовних конструкцій, які складно зрозуміти з першого погляду, а також для умов, що повторюються в коді.

3.3.2 Проблема
	У коді використовується складна умова, яка перевіряє, чи є користувач адміністратором або чи дійсна його ліцензія. Ця умова є довгою, містить логічні операції та дублюється в обох гілках. Такий підхід об'єднує різні логічні перевірки (роль користувача, активність ліцензії, лічильник входів) в один довгий вираз, що важко прочитати та зрозуміти. Недоліки такого неправильного підходу в тому що, код стає плутаним і важким для сприйняття; відбувається дублювання логіки в обох гілках умови; складно тестувати окремі частини умови, а також важко вносити зміни через високий рівень зв’язності.

 01 // Код ДО рефакторингу
 02 if (user->role == ADMINISTRATOR || (user->license_is_active && user->login_count > 0)) {
03 grant_system_access(user);
04 log_access_attempt(user, "SUCCESS");
05  } else {
06  deny_system_access(user);
07    log_access_attempt(user, "FAILURE");
08  }

3.3.3 Рішення
 Потрібно умову та логіку гілок винесено в окремі функції з зрозумілими назвами. Умовні перевірки винесено в окремі функції user_has_admin_privileges() та user_has_valid_license(), а також оптимізовано логування.
Переваги такого коду в тому що, код тепер став зрозумілішим, функції можна повторно використовувати, логіка прихована в простих блоках та легше тестування і зміна логіки.

01  // Основний код став більш формальним
02  if (user_has_admin_privileges(user) || user_has_valid_license(user)) {
03  grant_system_access(user);
04  } else {
05    deny_system_access(user);
06  }
07  log_access_attempt(user, is_access_granted ? "SUCCESS" : "FAILURE");
08  // Логіка прихована в простих функціях
09  bool user_has_admin_privileges(const User *user) {
10    return (user->role == ADMINISTRATOR);
11  }
12  bool user_has_valid_license(const User *user) {
13    return (user->license_is_active && user->login_count > 0);
14  }

3.4 Метод 2 - об’єднання дубльованих частин умов
	3.4.1 Опис методу
Метод використовується для усунення дублювання коду, яке повторюється в різних гілках умовного оператора. Він полягає у винесенні спільного коду за межі умови.

3.4.2 Проблема
У коді відправки даних на сервер однакові дії повторюються в обох гілках умови. Такий підхід призводить до дублювання коду, що повинен виконуватися незалежно від умови. Цей код порушує принципи DRY (Don't Repeat Yourself); збільшує загальний обсяг коду та його складність та ускладнення підтримки та модифікації цього коду.

01  if (is_connection_secure(client)) {
02    data = encrypt(request_data); // унікальна логіка для if
03    send_to_server(data);         // дублюється
04    log_transaction(client, data, "Secure send"); // дублюється
05  } else {
06    data = request_data;          // унікальна логіка для else
07    send_to_server(data);         // дублюється
08    log_transaction(client, data, "Insecure send"); // дублюється
09  }


3.4.3 Рішення
	Винисемо спільні дії за межі умови. Умови тепер відповідають лише за унікальну логіку. 
	Переваги такого коду перед попереднім в тому що, немає дублювання коду; легше вносити зміни в спільну логіку та код стає коротшим та зрозумілишим. 

01  // умова визначає лише унікальні параметри
02  if (is_connection_secure(client)) {
03    data = encrypt(request_data);
04    log_message = "Secure send";
05  } else {
06    data = request_data;
 07   log_message = "Insecure send";
08  }
09  // спільні дії винесені за межі умови
10  send_to_server(data);
11  log_transaction(client, data, log_message);

	3.5 Метод 3 - заміна алгоритму
3.5.1 Опис методу
Цей метод застосовується, коли поточний алгоритм є складним, неефективним або важким для розуміння. Він полягає у заміні тіла методу на новий, простіший та ефективніший алгоритм.

3.5.2 Проблема
	Використання неефективного алгоритму пошуку максимального значення з алгоритмічною складністю O(n²) та логічною помилкою (ігнорування від'ємних чисел). Такий підхід використовує вкладений цикл для вирішення задачі, яка може бути вирішена лінійно, а також некоректно ініціалізує початкове значення максимуму. Недоліки такого підходу в тому що, висока алгоритмічна складність (O(n²)) коли можна вирішити лінійно; критична логічна помилка при роботі з від'ємними числавми; код стає заплутаним і важким для аналізу а також низька продуктивність при великих обсягах даних.

01  int find_max(int array[], size_t size) {
02    int max_value = 0; // критична помилка, якщо всі числа від'ємні
03    for (size_t i = 0; i < size; i++) {
04      for (size_t j = i + 1; j < size; j++) {
05        // неефективно, поставимо O(n²) замість O(n)
06        if (array[j] > array[i] && array[j] > max_value) {
07          max_value = array[j];
08        }
09      }
10    }
11    return max_value;
12  }

3.5.3 Рішення
	Алгоритм замінено на лінійний (O(n)), видалено зайвий вкладений цикл та вирішено критичну помилку пр роботі з від’ємними числами.
	Переваги цього коду у тому що, в ньому підвищено продуктивність, спрощений порівняно з попереднім, покращення читабельності та усування алгоритмічних помилок.

01  int find_max(int array[], size_t size) {
02    // обробка крайового випадку
03    if (size == 0) {
04      return 0; // або можна показати помилку
05    }
06    // припускаємо що перший елемент максимальний
07    int max_value = array[0];
08    // проходимо решту масиву
09    for (size_t i = 1; i < size; i++) {
10      if (array[i] > max_value) {
11        max_value = array[i];
12      }
13    }
14    return max_value;
15  }





















ВИСНОВКИ

	Під час виконання практичної роботи було досліджено методи рефакторингу та проведено сам рефакторинг коду, проведення рефакторингу дозволило нам покращити структуру коду та зробити його більш зрозумілим і підтримуваним.
	У ході виконання роботи було застосовано три методи рефакторингу: Decompose Conditional, Consolidate Duplicate Conditional Fragments та Substitute Algorithm, кожен із цих методів дозволив вирішити конкретні проблеми коду:
- Decompose Conditional бореться зі складністю умовних виразів через їхнє розбиття на окремі функції, що робить код більш модульним і зрозумілим
- Consolidate Duplicate Conditional Fragments усуває дублювання коду через винесення спільної логіки за межі умовних блоків, що полегшує підтримку та зменшує ризик помилок.
- Substitute Algorithm замінює неефективні алгоритми на кращі, підвищуючи продуктивність, виправляючи логічні помилки та покращуючи ясність коду
Рефакторинг є важливою складовою процесу розробки програмного забезпечення, оскільки він покращує якість, підтримуваність та гнучкість коду, роблячи його готовим до майбутніх змін. Застосування цих методів не лише покращує технічні характеристики коду, але й сприяє кращій співпраці в команді, оскільки зрозумілий і добре організований код легше аналізувати та модифікувати.







ВИКОРИСТАНІ ДЖЕРЕЛА

1. Fowler, Martin. Refactoring. Improving the Design of Existing Code. Addison-Wesley Professional, 1999. – 464 p
2. GNU Coding Standards. URL: https://www.gnu.org/prep/standards/
	3. Kernighan, B. W., & Ritchie, D. M. The C Programming Language. 2nd Edition. Prentice Hall, 1988.
























ДОДАТОК А
Відеозапис
Посилання на запис: https://youtu.be/Hpuz0zmX3OQ

Хронологічний опис відеозапису
0:00 - Початок 
0:34 - Вступ 
1:58 - Головні принципи GSC для мови С
3:22 - Метод 157 Декомпозиція умов 
5:09 - Приклад до рефакторингу методом 157
5:47 - Приклад після рефакторингу методом 157
7:18 - Метод 160 Об'єднання дубльованих частин умов 
8:34 - Приклад до рефакторингу методом 160
10:01 - Приклад після рефакторингу методом 160
11:34 - Метод 139 Заміна алгоритму 
12:55 - Приклад до рефакторингу методом 139
14:06 - Приклад після рефакторингу методом 139
15:31 - Висновки та використовуванні джерела













ДОДАТОК Б
Слайди презентації
 
Рисунок Б1 – Титульний слайд презентації

 
Рисунок Б2 – Поняття рефакторингу


 
Рисунок Б3 – GNU Coding Standards для мови C

 
Рисунок Б4 – Метод №157 - Decompose Conditional (Декомпозиція умов)


 
Рисунок Б5 – Decompose Conditional, приклад до рефакторингу

 
Рисунок Б6 – Decompose Conditional, приклад після реакторингу нашим методом


  
Рисунок Б7 – Метод№160 Consolidate Duplicate Conditional Fragments (Об’єднання дубльованих частин умов)

 
Рисунок Б8 – Consolidate Duplicate Conditional Fragments, приклад до рефакторингу

 
Рисунок Б9 – Consolidate Duplicate Conditional Fragments, приклад після

 
Рисунок Б10 – Метод #139: Substitute Algorithm (Заміна алгоритму)

 
Рисунок Б11 – Substitute Algorithm, приклад до рефакторінгу

 
Рисунок Б12 – Substitute Algorithm, приклад після



 
Рисунок Б13 – Висновки

 
Рисунок Б14 – Перелік джерел
